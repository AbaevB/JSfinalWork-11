Вопрос по JavaScript: мне нужно реализовать пагинацию для блока с карточками в соответствии с этими требованиями:

``md
# Пагинация в блоке catalog

> Прежде чем реализовать логику работы пагинации, нужно её разбить на страницы и доработать логику отрисовки карточек с товарами.

## Доработка логики отрисовки карточек

1. Изначально на странице должно отображаться не больше шести карточек.

2.  Если карточек больше шести, лишние объекты скрываются и появляется пагинация.

3. Чтобы выбрать и отрисовать нужное количество карточек, воспользуйтесь методом массива `.slice(start, end)`. Он поможет вам извлечь из общего массива только те карточки, которые нужно отобразить на текущей странице.

4. Пагинация отображается, если общее количество карточек больше шести. Например, если карточек восемь, в пагинации должно быть два элемента (страницы 1 и 2). Если карточек 20, в пагинации должно быть четыре элемента (страницы 1–4).

## Логика работы пагинации:

1. Если количество карточек больше шести, должна работать пагинация.

2. Если всего карточек восемь, в пагинации должно быть два элемента (страницы 1 и 2). Например, при нажатии на номер страницы 2 должны отрисовываться карточки 7–8. Для этого используйте метод массива `.slice(6, 8)`.

3. Если всего карточек 20, при нажатии на номер страницы 3 должны отрисовываться карточки 13–18. Для этого используйте метод .`slice(12, 18)`.


```

Я начал реализацию задачи

1. Создать для блока пагинации класс `Pagination` на основе темплейта:

```html
    <template id="paginationTemplate">
      <ol class="catalog__pagination visually-hidden" id="catalogPagination">
        <li class="catalog__pagination-item">
          <button class="catalog__pagination-link">
            1
          </button>
        </li>
      </ol>
    </template>

```
JS код класса Pagination:

```js
// components/Pagination.js

export default class Pagination {
  constructor(totalPages, onPageChange, id) {
    this.totalPages = totalPages;
    this.currentPage = 1;
    this.onPageChange = onPageChange;
    this.template = document.getElementById('paginationTemplate');
    this.element = null;
    this.id = id;

    this.create();
  }

  create() {
    let clone = this.template.content.cloneNode(true);
    this.element = clone.querySelector('.catalog__pagination');
    this.element.id = this.id; // Устанавливаем уникальный id

    for (let i = 1; i <= this.totalPages; i++) {
      let li = document.createElement('li');
      li.classList.add('catalog__pagination-item');

      let pageLink = document.createElement('button');
      pageLink.classList.add('catalog__pagination-link');
      pageLink.textContent = i;
      pageLink.addEventListener('click', () => {
        this.onPageChange(i);
      });
      li.appendChild(pageLink);
      this.element.appendChild(li);
    }

    return this.element;
  }



  update(currentPage) {
    this.currentPage = currentPage;
    let links = this.element.querySelectorAll('.catalog__pagination-link');
    links.forEach(link => {
      if (link.textContent === currentPage.toString()) {
        link.setAttribute('disabled', true); // Устанавливаем disabled
      } else {
        link.removeAttribute('disabled'); // Убираем disabled
      }
    });
  }

  updatePagination(totalPages) {
    this.totalPages = totalPages;
    this.element.innerHTML = ''; // Очищаем существующие кнопки

    for (let i = 1; i <= this.totalPages; i++) {
      let li = document.createElement('li');
      li.classList.add('catalog__pagination-item');

      let pageLink = document.createElement('button');
      pageLink.classList.add('catalog__pagination-link');
      pageLink.textContent = i;
      pageLink.addEventListener('click', () => {
        this.onPageChange(i);
      });
      li.appendChild(pageLink);
      this.element.appendChild(li);
    }
  }
}
```

2. В модуле `js/components/Catalog.js` реализовать отображение в блоке `catalogListEl` не более 6 карточек - если карточек больше 6, у созданного в блоке `containerEl` экземпляра класса `Pagination` убирается класс `visually-hidden`. В этом же модуле осуществляется остальная логика отрисовки - учет изменений количества и порядка карточек при применении фильтров и сортировки, etc..

Код компонента Catalog.js

```js

// components/Catalog.js

import ProductCard from './ProductCard.js';
import fetchProducts from './FetchData.js';

export default async function catalog() {
    // Получаем данные о товарах
    let products = await fetchProducts();


    // Обновляем DOM
    let catalogListEl = document.getElementById('catalogList');
    catalogListEl.innerHTML = '';

    let cards = [];
    // Создание карточек
    products.forEach(product => {
        let card = new ProductCard(product);
        let liEl = document.createElement('li');
        liEl.classList.add('catalog__item');
        card.appendTo(liEl);
        cards.push(card);
        catalogListEl.appendChild(liEl);
    });

    console.log(cards);
    return cards;
}

```

3. В модуле `js/components/CatalogPagination.js` будет реализована логика работы пагинации.



### Для справки - код модулей фмльтрации и сортировки, влияющих на количество  и порядок отображения карточек в каталоге

Приьунение фильтров:

```js
// components/ApplyFilters.js

import ProductCard from './ProductCard.js';

function applyFilters(data) {
  let formEl = document.getElementById('filterForm');
  let checkEls = formEl.querySelectorAll('.custom-checkbox__field');
  let inStockEl = document.getElementById('instock');
  let allItemEl = document.getElementById('all-item');
  let resetEl = document.getElementById('filterResetBtn');

  // Формирование активного списка фильтров
  let activeCategories = Array.from(checkEls).filter(cb => cb.checked).map(cb => cb.value);
  let stockFilter = inStockEl.checked ? 'instock' : 'all-item';

  // Фильтрация товаров
  let filteredProducts = data.filter(product => {
    // Проверка по категориям
    let matchesCategories = activeCategories.every(cat => product.type.includes(cat));

    // Проверка по доступности
    let matchesStock = stockFilter === 'all-item' ||
      (stockFilter === 'instock' && Object.values(product.availability).some(count => count > 0));

    return matchesCategories && matchesStock;
  });

  // Обновление DOM
  let catalogListEl = document.getElementById('catalogList');
  catalogListEl.innerHTML = ''; // Очищаем старый список карточек

  // Рендеринг новых карточек
  filteredProducts.forEach(product => {
    let card = new ProductCard(product);
    let liEl = document.createElement('li');
    liEl.classList.add('catalog__item');
    card.appendTo(liEl);
    catalogListEl.appendChild(liEl);
  });
}

// Функция для сброса фильтров
function resetFilters(data) {
  // Сброс чекбоксов
  let checkEls = document.querySelectorAll('.custom-checkbox__field');
  checkEls.forEach(checkbox => {
    checkbox.checked = false;
  });

  // Сброс радиокнопок
  let radioEls = document.querySelectorAll('.custom-radio__field');
  radioEls.forEach(radio => {
    if (radio.value === 'all-item') {
      radio.checked = true;
    } else {
      radio.checked = false;
    }
  });

  // Повторная фильтрация
  applyFilters(data);
}

// Обработчики событий
function registerHandlers(data) {
  let formEl = document.getElementById('filterForm');
  let checkEls = formEl.querySelectorAll('.custom-checkbox__field');
  let inStockEl = document.getElementById('instock');
  let allItemEl = document.getElementById('all-item');
  let resetEl = document.getElementById('filterResetBtn');

  // Обработчики чекбоксов
  checkEls.forEach(checkbox => {
    checkbox.addEventListener('change', () => {
      applyFilters(data);
    });
  });

  // Обработчики радиокнопок
  inStockEl.addEventListener('change', () => {
    applyFilters(data);
  });

  allItemEl.addEventListener('change', () => {
    applyFilters(data);
  });

  // Обработчик сброса
  resetEl.addEventListener('click', () => {
    resetFilters(data);
  });
}

// Регистрация обработчиков один раз
function initialize(data) {
  registerHandlers(data);
}

export {
  applyFilters,
  resetFilters,
  initialize,
};


```

Сортировка карточек:

```js
// components/SortingCards.js

import ProductCard from './ProductCard.js';
import fetchProducts from './FetchData.js';

export default async function sortingCards() {
  let sortingEl = document.getElementById('sorting');

  // Обработчик изменения селекта
  sortingEl.addEventListener('change', async () => {
    let sortOption = sortingEl.value;

    // Получение данных о товарах из JSON
    let products = await fetchProducts();

    // Сортировка товаров
    let sortedProducts = sortProducts(products, sortOption);

    // Обновление DOM
    let catalogListEl = document.getElementById('catalogList');
    catalogListEl.innerHTML = ''; // Очистка контейнера с карточками (шаблон вынесен для безопасности в body)

    // Отрисовка отсортированных карточек
    sortedProducts.forEach(product => {
      let card = new ProductCard(product);
      let liEl = document.createElement('li');
      liEl.classList.add('catalog__item');
      card.appendTo(liEl);
      catalogListEl.appendChild(liEl);
    });
  });

  // Функция для сортировки товаров
  function sortProducts(products, option) {
    switch (option) {
      case 'price-min': // Сначала дешевые
        return [...products].sort((a, b) => a.price.new - b.price.new);
      case 'price-max': // Сначала дорогие
        return [...products].sort((a, b) => b.price.new - a.price.new);
      case 'rating-max': // Сначала популярные
        return [...products].sort((a, b) => b.rating - a.rating);
      default:
        return products;
    }
  }
}

```
Мне нужно доработать код модуля `js/components/Catalog.js` и написать код для компонента `js/components/CatalogPagination.js` для того, чтобы реализовать пагинацию на странице с учетом требований заказчика



